Index: binutils/bfd/elf32-avr32.c
===================================================================
--- binutils/bfd/elf32-avr32.c	(revision 38993)
+++ binutils/bfd/elf32-avr32.c	(working copy)
@@ -244,10 +244,12 @@
 
 /*
   Try to limit memory usage to something reasonable when sorting the
-  GOT.  If we ever get more than this many references to the same
-  symbol, we may need to do something special.
+  GOT.  If just a couple of entries end up getting more references
+  than this, it won't affect performance at all, but if there are many
+  of them, we could end up with the wrong symbols being assigned the
+  first GOT entries.
 */
-#define MAX_NR_GOT_HOLES	8192
+#define MAX_NR_GOT_HOLES	2048
 
 /*
   AVR32 GOT entry.  We need to keep track of refcounts and offsets
@@ -916,16 +918,21 @@
 static void
 insert_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got)
 {
-  /* TODO: Support got_refcount > htab->nr_got_holes by using a
-     different sort algorithm for those.  */
-  BFD_ASSERT(got->refcount <= htab->nr_got_holes);
+  /* Any entries with got_refcount > htab->nr_got_holes end up in the
+   * last pigeonhole without any sorting. We expect the number of such
+   * entries to be small, so it is very unlikely to affect
+   * performance.  */
+  int entry = got->refcount;
 
-  got->pprev = &htab->got_hole[got->refcount];
-  got->next = htab->got_hole[got->refcount];
+  if (entry > htab->nr_got_holes)
+    entry = htab->nr_got_holes;
+
+  got->pprev = &htab->got_hole[entry];
+  got->next = htab->got_hole[entry];
   if (got->next)
     got->next->pprev = &got->next;
 
-  htab->got_hole[got->refcount] = got;
+  htab->got_hole[entry] = got;
 }
 
 /* Decrement the refcount of a GOT entry and update its position in
@@ -933,7 +940,6 @@
 static void
 unref_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got)
 {
-  BFD_ASSERT(got->refcount <= htab->nr_got_holes);
   BFD_ASSERT(got->refcount > 0);
 
   if (got->next)
@@ -955,7 +961,6 @@
   insert_got_entry(htab, got);
 
   BFD_ASSERT(got->refcount > 0);
-  BFD_ASSERT(got->refcount <= htab->nr_got_holes);
 }
 
 /* Assign offsets to all GOT entries we intend to keep.  The entries
@@ -1106,13 +1111,16 @@
     {
       /* Allocate holes for the pigeonhole sort algorithm */
       pr_debug("Highest GOT refcount: %d\n", htab->nr_got_holes);
+
+      /* Limit the memory usage by clipping the number of pigeonholes
+       * at a predefined maximum. All entries with a higher refcount
+       * will end up in the last pigeonhole.  */
       if (htab->nr_got_holes >= MAX_NR_GOT_HOLES)
 	{
-	  /* TODO: Do something clever (different sorting algorithm) */
-	  _bfd_error_handler(_("Highest refcount %d too high (max %d)\n"),
-			     htab->nr_got_holes, MAX_NR_GOT_HOLES);
-	  bfd_set_error(bfd_error_no_memory);
-	  return FALSE;
+	  htab->nr_got_holes = MAX_NR_GOT_HOLES - 1;
+
+	  pr_debug("Limiting maximum number of GOT pigeonholes to %u\n",
+			     htab->nr_got_holes);
 	}
       htab->got_hole = bfd_zalloc(output_bfd,
 				  sizeof(struct got_entry *)
